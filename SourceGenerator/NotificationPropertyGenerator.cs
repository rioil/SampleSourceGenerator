using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace SourceGenerator
{
    [Generator]
    internal class NotificationPropertyGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(GenerateNotificationPropertyAttribute);

            // MEMO: どちらの記述でも同じ処理
            //IncrementalValueProviderExtensions.Select(context.CompilationProvider, GetNotificationPropertyAttributeSymbol);
            var notificationPropertyAttribute = context.CompilationProvider.Select(GetNotificationPropertyAttributeSymbol);
            var notifyPropertyChangedInterface = context.CompilationProvider
                .Select((compilation, cancellationToken) => compilation.GetTypeByMetadataName("System.ComponentModel.INotifyPropertyChanged"));

            var fieldsWithAttribute = context.SyntaxProvider.CreateSyntaxProvider(IsFieldDeclarationWithAttribute, GetFieldDeclarationSyntax)
                .SelectMany((fields, cancellationToken) => fields)
                .Combine(notificationPropertyAttribute)
                .Select(HasAttribute)
                .Where(x => x is not null)
                .Select((field, cancellationToken) => field!)
                .Combine(notifyPropertyChangedInterface);
            context.RegisterSourceOutput(fieldsWithAttribute, (ctx, pair) =>
            {
                var field = pair.Left;
                var notifyPropertyChangedInterface = pair.Right;

                if (notifyPropertyChangedInterface is null) { return; }
                if (!field.ContainingType.AllInterfaces.Contains(notifyPropertyChangedInterface))
                {
                    var location = Location.None;
                    if (field.ContainingType is { Locations: { Length: > 0 } locations })
                    {
                        location = locations[0];
                    }

                    ctx.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                        "SSG0001",
                        "Types that own fields with NotificationPropertyAttribute must implement INotifyPropertyChanged",
                        "Implement System.ComponentModel.INotifyPropertyChanged on '{0}' because it creates members with NotificationPropertyAttribute: '{1}'.",
                        "Sample Source Generator",
                        DiagnosticSeverity.Error,
                        true), location, field.ContainingType?.Name, field.Name));
                }

                var propertyName = ConvertToPropertyName(field.Name);
                ctx.AddSource($"{field.ContainingType?.ToDisplayString()}_{field.Name}", $$"""
                    // <auto-generated/>
                    namespace {{field.ContainingNamespace.ToDisplayString()}} {
                        partial class {{field.ContainingType?.Name}} {
                            public {{field.Type.ToDisplayString()}} {{propertyName}} {
                                get => {{field.Name}};
                                set {
                                    if (value != {{field.Name}}) {
                                        {{field.Name}} = value;
                                        PropertyChanged?.Invoke(this, new global::System.ComponentModel.PropertyChangedEventArgs(nameof({{propertyName}})));
                                    }
                                }
                            }
                        }
                    }
                    """);
            });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        private void GenerateNotificationPropertyAttribute(IncrementalGeneratorPostInitializationContext context)
        {
            context.AddSource("NotificationPropertyAttribute.g.cs", """
                namespace SourceGenerator
                {
                    [global::System.AttributeUsage(global::System.AttributeTargets.Field)]
                    public class NotificationPropertyAttribute : global::System.Attribute
                    {
                    }
                }
                """);
        }

        private INamedTypeSymbol GetNotificationPropertyAttributeSymbol(Compilation compilation, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("SourceGenerator.NotificationPropertyAttribute") ?? throw new InvalidOperationException();
        }

        private bool IsFieldDeclarationWithAttribute(SyntaxNode node, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            return node is FieldDeclarationSyntax { AttributeLists.Count: > 0 };
        }

        private IEnumerable<IFieldSymbol> GetFieldDeclarationSyntax(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            var fieldDeclaration = (FieldDeclarationSyntax)context.Node;

            foreach (var variable in fieldDeclaration.Declaration.Variables)
            {
                var symbol = (IFieldSymbol?)context.SemanticModel.GetDeclaredSymbol(variable, cancellationToken);
                if (symbol is not null)
                {
                    yield return symbol;
                }
            }
        }

        private IFieldSymbol? HasAttribute((IFieldSymbol? Field, INamedTypeSymbol Type) pair, CancellationToken cancellationToken)
        {
            if (pair.Field is null) { return null; }

            foreach (var attribute in pair.Field.GetAttributes())
            {
                cancellationToken.ThrowIfCancellationRequested();
                if (SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, pair.Type))
                {
                    return pair.Field;
                }
            }

            return null;
        }

        private string ConvertToPropertyName(string fieldName)
        {
            int offset = 0;
            if (fieldName[0] == '_')
            {
                offset = 1;
            }
            StringBuilder builder = new(fieldName.Length - offset);

            builder.Append(char.ToUpper(fieldName[offset++]));
            builder.Append(fieldName, offset, fieldName.Length - offset);
            return builder.ToString();
        }
    }
}
